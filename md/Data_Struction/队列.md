<font size = 4>

## 数组模拟队列
### 代码模板

```c++
const int N = 1e6 + 10;
int q[N], hh = 0, rr = -1;

void push(int x) {
    q[++rr] = x;
}

void pop() {
    ++hh;
}

void isempty() {
    return hh <= tt;
}

void query() {
    cout << q[hh] << endl;
}
```
## 滑动窗口：求滑动窗口里的==最小值==

### 思路分析：
* 如果下标i、j都在滑动窗口内部， 而且i < j, 但是a[i] > a[j], 因此， a[i]永远不可能作为答案出现。
* 因此， 每次在队列里插入的数时应保证队尾元素比要插入的数小，因此构造出单调递增的队列。


```c++
const int N = 1e6 + 10;
int a[N],q[N];
int hh, tt;
void solve() {
    int n,k; scanf("%d%d",&n,&k);
    for(int i = 0; i < n; i++) scanf("%d",&a[i]);
    hh = 0, tt = -1;
    for(int i = 0; i < n; i++){
        if (hh <= tt && i - k + 1 > q[hh]) hh ++ ; 

        while (hh <= tt && a[q[tt]] >= a[i]) tt -- ;
        q[ ++ tt] = i;

        if (i >= k - 1) printf("%d ", a[q[hh]]);

    }
}
```


</font>