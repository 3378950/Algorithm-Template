<font size = 3>


## 拓展欧几里得算法
### 题目描述：
$求出一组x_i,y_i, 使得其满足a \times x + b \times y = gcd(a, \ b)$
### 裴蜀定理：
* 对于一对正整数$a, b$,一定存在非零整数 $x, y$ , 使得 $a \times x + b \times y = gcd(a, \  b)$

### 思路：

 $当b = 0 时，gcd(a,b) = a, 则a \times x + b \times y = a, 因此 x = 1, y = 0$
 
 $当递归结束时， 满足b \times y + (a \ mod \ b) \times x = gcd(a, \ b)  $ 
 
 $a \ mod \ b = a - \lfloor  \frac a b  \rfloor \times b$
 
 $a \times x + b \times (y - \lfloor  \frac a b  \rfloor \times x) = gcd(a, \ b) $
 
 $a \times x_0 + b \times y_0 = d $

```math
\begin{cases}
x = x_0 - \frac b d \times k \\
y = y_0 + \frac b d \times k \ 
\end{cases}

k为整数

 ```

### 代码模板
```c++
int exgcd(int a, int b, int &x, int &y) {
    if(!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d; // 结果为x, y
}
```


## 拓展欧几里得算法应用： 求线性同余方程
### 题目描述： 
$求一个x_i, 使其满足a_i \times x_i \equiv b_i(mod \ m)  $

$a_i \times x_i \equiv b_i(mod \ m) $

$\exists x , \ s.t.\ a \times x + m \times y = b  (其中b 是gcd(a, m)的倍数即可,否则无解)$

### 代码
```c++
int exgcd(int a, int b, int &x, int &y) {
    if(!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

void solve() {
    int a, b, m; scanf("%d%d%d", &a, &b, &m);
    int x, y; int d = exgcd(a, m, x, y);
    if(b % d) puts("impossible");
    else printf("%d\n", (LL) x * (b / d) % m);
}
```

</font>