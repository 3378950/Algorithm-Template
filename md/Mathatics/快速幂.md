<font size=4>

## 题目描述：求出$a^k$%p的值。
### 思路：

* 预先计算出从$2^0到2^{logk}$所有的值
* 根据k的二进制表示用之前计算出的值组合相乘使之等于k



### 代码模板

```c++
int qmi(int a, int k, int p) {
    int ans =  1 % p;
    while(k) {
        if(k & 1) ans = (LL)ans * a % p;
        k >>= 1;
        a = (LL) a * a % p; // a每次只需平方即可
    }
    return ans;
}
```
### 快速幂求逆元
#### 定义：
```math
若整数b，m互质，并且对于任意的整数a，如果满足b|a，则存在一个整数x，使得a/b≡a\times x(mod \ m),则称x为b的模m乘法逆元，记为b^{-1} (mod \ m) 
```
#### 思路：
```math

如果  \frac a b \equiv a\times x (mod \  p), 则称x 为b 的(mod \ p)逆元, 记作b^{-1}\\


从上式可以看出， 逆元可以将复杂的除法转换成乘法 \\ 
给出计算公式：


b^{-1} = b^{p - 2}

```
#### 简单证明
```math
已知 ：\frac a b \equiv a\times x (mod \  p)     

a \equiv a \times b^{-1}\times b  

即   b \times b^{-1} \equiv 1(mod \ p) 

已知 b、p 互质， 根据费马定理 ：

b^{p - 1} \equiv 1(mod \  p)

因此：b^{-1} = b^{p - 2}

```
#### 代码模板
```c++
int qmi(int a, int k, int p) {
    int ans = 1 % p;
    while(k) {
        if(k & 1) ans = (LL) ans * a % p;
        k >>= 1;
        a = (LL) a * a % p;
    }
    return ans;
}

void solve() {
    int a, p; scanf("%d%d", &a, &p);
    int ans = qmi(a, p - 2, p);
    if(a % p) printf("%d\n", ans);
    else puts("impossible");
}
```


</font>



