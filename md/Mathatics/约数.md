<font size=4>

## 试除法求约数
### 思路： 
* 可以从$1$一直遍历到 $\sqrt x$, 如果找到一个约数， 由于约数是成对出现的， 因此， 只需要计算另一个约数即可

### 代码模板
```c++
void solve() {
    vector<int> st;
    int x; scanf("%d", &x);
    for(int i = 1; i <= x / i; i++) {
        if(x % i == 0) { 
        st.push_back(i); 
        if(i != x / i) st.push_back(x / i);}
    }
    sort(st.begin(), st.end());
    for(auto x : st) printf("%d ",x);
    puts("");
}
```
## 约数的个数
### 思路：
```math
 N = \prod_{i = 1}^k {p_i}^{\alpha_i} = {p_1}^{\alpha_1} \times {p_2}^{\alpha_2} \times {p_3}^{\alpha_3} \times ... \times {p_k}^{\alpha_k}


 ans = \prod_{i = 1}^k (\alpha_i + 1) 
```
### 证明：
```math
整数N的任意一个约数d均可表示为：d = \prod_{i = 1}^k {p_i}^{\beta_i}, 其中每一个\beta有 C_{\alpha_i}^{1}择， 因此d共有\prod_{i = 1}^k (\alpha_i + 1)种选法

```
### 代码模板：
```c++
void solve() {
    unordered_map<int, int> primes;
    int x ; cin >> x;
        for(int i = 2; i <= x / i; i++) {
            while(x % i == 0) {
                x /= i;
                primes[i] ++;
            }
        }
    if(x > 1) primes[x]++;
    LL ans = 1;
    for(auto s: primes) ans = ans * (s.second + 1) % MOD;
    cout << ans << endl;
}
```
## 约数之和
###  思路：
```math
N = \prod_{i = 1}^k {p_i}^{\alpha_i} = {p_1}^{\alpha_1} \times {p_2}^{\alpha_2} \times {p_3}^{\alpha_3} \times ... \times {p_k}^{\alpha_k} 
```

```math
ans = \prod_{i = 1}^k \sum_{j = 0}^{k}p_i^j = (p_1^0 + p_1^1 + ... + p_1^k) \times ... \times(p_k^0 + ... + p_k^k)
```
### 代码模板
```c++
void solve() {
    unordered_map<int, int> primes;
    int x ; cin >> x;
    for(int i = 2; i <= x / i; i++) {
        while(x % i == 0) {
            x /= i;
            primes[i] ++;
        }
    }
    if(x > 1) primes[x]++;
    LL res = 1;
    for (auto p : primes) {
        LL a = p.first, b = p.second;
        LL t = 1;
        while (b -- ) t = (t * a + 1) % MOD;
        res = res * t % MOD;
    }
    cout << res << endl;
}
```
## 最大公约数
### 欧几里得算法
```c++
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
</font>