<font size=4>


### 整数二分： 

#### 代码模板：
```c++
// >= x : The smallest of the conditions
while(l < r) {
    int mid = (l + r) >> 1;
    if(a[mid] >= x) r = mid;
    else l = mid + 1;
}
------------------------
// <= x : the biggest of the conditions
while(l < r) {	
	int mid = (l + r + 1) >> 1; // 防止发生死循环
    if(a[mid] <= x) l = mid; 
    else r = mid - 1;
}
```
#### 例题： [数的范围]: https://www.acwing.com/problem/content/791/
> 给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。
> 如果数组中不存在该元素，则返回“-1 -1”。

> 输入格式:<br> 第一行包含整数n和q，表示数组长度和询问个数。<br>
第二行包含n个整数（均在1~10000范围内），表示完整数组。<br>
接下来q行，每行包含一个整数k，表示一个询问元素。
输出格式
共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。
如果数组中不存在该元素，则返回“-1 -1”。
数据范围: 
1≤n≤100000 
1≤q≤10000 
1≤k≤10000 
输入样例：
6 3 
1 2 2 3 3 4 
3 
4 
5 
输出样例：
3 4 
5 5 
-1 -1

##### 思路： 
* 找到第一个满足条件的数的下标
* 如果有第一个下标存在， 继续找其终止位置

##### 完整代码
```c++
#include <iostream>

using namespace std;

const int N = 1e5+10;
int a[N];

int main(){
    int n, k; scanf("%d%d",&n,&k);
    for(int i = 0; i < n; i++) scanf("%d", &a[i]);
    for(int i = 0; i < k; i++) {
        int x; scanf("%d", &x);
        int l = 0,r = n - 1;
        while(l < r) {
            int mid = l + r >> 1;
            if(a[mid] >= x) r = mid;
            else l = mid + 1;
        }
        if(a[l] != x) printf("-1 -1\n"); // 不存在
        else {
            printf("%d ", l);
            int l = 0, r = n - 1;
            while(l < r) {
                int mid = l + r + 1>> 1;
                if(a[mid] <= x) l = mid;
                else r = mid - 1;
            }
            printf("%d\n", l);
        }
    }
    return 0;
}
```
### 浮点数二分
#### 例题 ： [数的三次方根] : https://www.acwing.com/problem/content/792/

##### 代码
```c++
#include <iostream>
using namespace std;
int main() {
    double x; scanf("%lf", &x);
    double l = -100, r = 100;
    while(r - l > 1e-8) {
        double mid = (l + r) / 2;
        if(mid * mid * mid <= x) l = mid;
        else r = mid;
    }
    printf("%6f", l);
    return 0;
}
```
</font>