<font size = 4>

## 背包问题：
* 问题描述有$n$件物品， 每件物品的体积为$V_i$,价值为$W_i$, 有一个体积为$V$的背包， 求总体积不大于$V$的所有物品总价值最大是多少

### 01背包问题: 每件物品只能用一次

#### 状态表示： dp[i][j]
* 集合：所有选法
* 条件：仅从前$i$个物品中选择，而且使得总体积不超过$j$
* 属性：dp[i][j], 最大价值

#### 状态计算： 集合的划分
![image](https://note.youdao.com/yws/api/personal/file/WEB26c5d921f1ada7b602ab5fcf1ef03fe7?method=download&shareKey=b8c76d259aec9500fb6760f4073e01ab)

#### 朴素做法：二维
```c++
void solve() {
    for(int i = 1; i <= N; i++) {
        for(int j = 0; j <= V; j++) {
            dp[i][j] = dp[i - 1][j];
            if(v[i] <= j) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);
        }
    }
    printf("%d\n", dp[N][V]);
}
```

#### 优化版本：等价变形，每一层由于上一层有关
```c++
void solve() {
    for(int i = 1; i <= N; i++) 
        for(int j = V; j >= v[i]; j--) 
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    printf("%d\n", dp[V]);
}
```

### 完全背包：每件物品无使用次数的限制
#### 朴素做法
```c++
void solve() {
    for(int i = 1; i <= n; i++) // 枚举所有用到物品
        for(int j = 0; j <= V; j++) // 枚举所有体积
            for(int k = 0; k * v[i] <= j; k++) // 枚举每件物品用到的次数
                dp[i][j] = max(dp[i][j], dp[i - 1][j - k * v[i]] + w[i] * k);
    cout << dp[n][V];
}
```
#### 优化-1
##### 优化思路：

```math
dp(i, j) = dp(i - 1, j - v_i \times k) + w_i \times k; \\
```

$dp(i, j)$展开式：

```math
dp(i, j) = max(dp(i - 1, j), dp(i - 1, j - v_i) + w_i, dp(i - 1,j - 2 \times v_i + 2 \times w_i，...)\\
dp(i,j - v_i) = max(dp(i - 1,j - v), dp(i - 1,j - 2 \times v_i + w_i, ...)\\
```

由以上两式可得：

```math
dp(i, j) = max(dp(i - 1, j), dp(i, j - v_i) + w_i)
```


```c++
void solve() {
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j <= V; j++) {
            dp[i][j] = dp[i - 1][j];
            if(j >= v[i]) dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]);
        }
    }
    cout << dp[n][V];
}
```

#### 优化-2: 变成一维

```c++
void solve() {
    for(int i = 1; i <= n; i++) {
        for(int j = v[i]; j <= V; j++) 
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
    cout << dp[V];
}
```

#### 完全背包与01背包的区别：状态方程的比较
* 01背包：$ dp(i,j) = max(dp(i - 1, j), dp(i - 1, j - v_i) + w_i)$
* 完全背包： $ dp(i, j) = max(dp(i - 1, j), dp(i, j - v_i) + w_i)$

### 多重背包：每个物品的数量有限：仅有s[i]个

#### 朴素暴力做法： $O(nms)$

```c++
void solve() {
    for(int i = 1; i <= n; i++) 
        for(int j = 0; j <= V; j++) 
            for(int k = 0; k <= s[i] && k * v[i] <= j; k++)
                dp[i][j] = max(dp[i][j], dp[i - 1][j - k * v[i]] + w[i] * k);
    cout << dp[n][V];
}
```

#### 优化版本：二进制拆分优化: $O(nmlogs)$

* 例如： 体积为$v$的物品有$s$个，将这些物品按照2的幂次方个物品打包成新物品，可将其转化成01背包问题。


```c++
void solve() {
    int cnt = 0;
    for(int i = 0; i < n; i++) {
        int a, b, c; scanf("%d%d%d", &a, &b, &c);
        int k = 1;
        while(k <= c) {
            cnt++;
            v[cnt] = k * a;
            w[cnt] = k * b;
            c -= k;
            k *= 2;
        }
        if(c) { // 2^k + c == v
            cnt++;
            v[cnt] = a * c;
            w[cnt] = b * c;
        }
    }
    
    for(int i = 1; i <= cnt; i++)
        for(int j = m; j >= v[i]; j--)
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
            
    printf("%d\n", dp[m]);
}
```


### 分组背包：

```c++
void solve() {
for(int i = 1; i <= n; i++) {
        scanf("%d", &s[i]);
        for(int j = 0; j < s[i]; j++)
            scanf("%d%d", &v[i][j], &w[i][j]);
    }
    for(int i = 1; i <= n; i++) 
        for(int j = m; j >= 0; j--)
            for(int k = 0; k < s[i]; k++)
                if(v[i][k] <= j)
                    dp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]);
                    
    printf("%d\n", dp[m]);
}
```
</font>
