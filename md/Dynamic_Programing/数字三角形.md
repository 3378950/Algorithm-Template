<font size = 4>

## 数字三角形

> 题目描述：给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。


>   7
>    3   8
>   8   1   0
>  2   7   4   4
> 4   5   2   6   5

> 数据范围： $$1 \leq n \leq 500$$$$-10000 \leq 三角形中的整数 \leq 10000$$


### 状态表示及计算
* 从正上方转移过来， 或者从左斜上方转移过来：

```math
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + mp[i][j]
```
### 初始化的细节
* 状态转移过程中可能会用到边界状态同时数据中存在负数， 因此初始化时将两边也初始化成INF(INF取-0x3f3f3f3f)

### 代码
```c++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 510, INF = -0x3f3f3f3f;
int dp[N][N], a[N][N];
int n;

int main() {
    
    cin >> n;
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= i; j++)
            scanf("%d", &a[i][j]);
            
    for(int i = 0; i <= n; i++)
        for(int j = 0; j <= i + 1; j++)
            dp[i][j] = INF;
    
    dp[1][1] = a[1][1];
    
    for(int i = 2; i <= n; i++) 
        for(int j = 1; j <= i; j++) 
            dp[i][j] = max(dp[i - 1][j] + a[i][j], dp[i - 1][j - 1] + a[i][j]);
            
    
    
    int ans = INF;
    for(int i = 1; i <= n; i++) ans = max(ans, dp[n][i]);
    cout << ans;
    return 0;
}
```

### 倒推法
* 从最底层开始往上推：
$$dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + mp[i][j]$$

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510;

int n;
int a[N][N];


int main() {
    cin >> n;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            cin >> a[i][j];

    for (int i = n - 1; i >= 1; i--)
        for (int j = 1; j <= i; j++)
            a[i][j] = max(a[i + 1][j] + a[i][j], a[i + 1][j + 1] + a[i][j]);

    cout << a[1][1];
    return 0;
}
```

## 有关数字三角形问题的拓展

### 摘花生





</font>